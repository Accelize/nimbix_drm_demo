#include <iostream>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>
#include <vector>
#include <thread>
#include <fcntl.h>
#include <ncurses.h>
#include <fstream>

// Accelize DRMLib
#include <mutex>
#include "accelize/drm.h"
using namespace Accelize::DRMLib;
std::mutex gDrmMutex;

using namespace std;

// Terminal Colors
#define RESET   	    "\033[0m"
#define BOLDBLACK       "\033[1m\033[30m"    /* Bold Black */
#define BOLDRED         "\033[1m\033[31m"    /* Bold Red   */
#define BOLDYELLOW      "\033[1m\033[33m"    /* Bold Yellow   */
#define BOLDGREEN       "\033[1m\033[32m"    /* Bold Green */
#define BOLDWHITE       "\033[1m\033[37m"    /* Bold White */
#define BGBOLDRED       "\033[1m\033[41m"    /* Bold Red   */
#define BGBOLDGREEN     "\033[1m\033[42m"    /* Bold Green */
#define BGBOLDWHITE     "\033[1m\033[47m"    /* Bold White */
#define HLCOLOR         "\033[1m\033[30;47m"
#define OKCOLOR         "\033[1m\033[37;42m"
#define KOCOLOR         "\033[1m\033[37;41m"
#define LOADCOLOR       "\033[1m\033[37;43m"

#define FCELLSIZE 				15
#define CELLSIZE  				12
#define MAX_NB_SLOTS            8
#define LOG_SIZE               10
#define SLOT_STATUS_DISABLED    0
#define SLOT_STATUS_ENABLED     1
#define IP_STATUS_UNKNOWN       0
#define IP_STATUS_STARTING      1
#define IP_STATUS_LOCKED        2
#define IP_STATUS_ACTIVATED     3
#define STATE_IDLE 				0
#define STATE_NO_LIC 			1
#define STATE_NO_SEAT			2
#define STATE_RUNNING			3
#define STATE_ERROR				4
#define FSM_IDLE 				0
#define FSM_INIT 				1
#define FSM_START_SESSION 		2
#define FSM_READ_IP_STATUS 		3
#define FSM_ERROR 				4

enum userNameIdx{ nancyIdx=0, fannyIdx, maryIdx, nbIdx};
uint32_t gUserNameIndex=maryIdx;

std::string gAllowedUsers[] 	= {std::string("nancy@accelize.com"), std::string("fanny@accelize.com"), std::string("mary@accelize.com")};
std::string gLicenseModeStr[] 	= {std::string("NODELOCKED"), std::string("FLOATING"), std::string("METERED")};
std::string gAppStatusStr[]  	= {std::string(" - "), std::string("STARTED")};
std::string gIpStatusStr[]    	= {std::string(""), std::string("Starting ..."), std::string("LOCKED"), std::string("ACTIVATED")};
std::string gIpStatusColor[]  	= {std::string(RESET), std::string(LOADCOLOR), std::string(KOCOLOR), std::string(OKCOLOR)};
std::string gSlotStateStr[] 	= {std::string(" "), std::string("NO_LIC"), std::string("NO_SEAT"), std::string("Running"), std::string("ERROR")};

enum {
	LICENSE_MODE_NODELOCKED=0,
	LICENSE_MODE_FLOATING,
	LICENSE_MODE_METERED,
	LICENSE_UNKNOWN
};

#ifdef NLPROV
std::string gDrmLibConfPath[] = {std::string("conf/nodelocked_prov/"), std::string("conf/floating/"), std::string("conf/metered/")};
#else
std::string gDrmLibConfPath[] = {std::string("conf/nodelocked/"), std::string("conf/floating/"), std::string("conf/metered/")};
#endif

// FPGA Design Defines
#define DRM_PAGE_REG_OFFSET     0x00000
#define DRM_STATUS_REG_OFFSET   0x00040
#define DRM_VERSION_REG_OFFSET  0x00068

typedef struct slotInfos {
	uint32_t slotID;
	uint32_t slotStatus;
    uint32_t ipStatus;
    uint32_t slotState;
} slotInfos_t;

typedef struct highlightCell {
	uint32_t slotID;
} highlightCell_t;

typedef struct dashBoard {
    uint32_t nbSlots;
    slotInfos_t slot[MAX_NB_SLOTS];
    highlightCell_t hlCell;
} dashBoard_t;

//char gSpinner1[] = {'|', '/', '-', '\\'};
//char gSpinner2[] = {'.', 'o', 'O', 'o'};
//char gSpinner3[] = {'V', '<', '^', '>'};
//char gSpinner4[] = {'+', 'x', '+', 'x'};

char gSpinner1[] = {'.', 'o', 'O', 'o', '.', '.', '.', '.'};
char gSpinner2[] = {'.', '.', 'o', 'O', 'o', '.', '.', '.'};
char gSpinner3[] = {'.', '.', '.', 'o', 'O', 'o', '.', '.'};
char gSpinner4[] = {'.', '.', '.', '.', 'o', 'O', 'o', '.'};
char gSpinner5[] = {'.', '.', '.', '.', '.', 'o', 'O', 'o'};
uint32_t maxSpinIdx = sizeof(gSpinner1);

dashBoard_t gDashboard;
std::string gUserName("mary@accelize.com");
bool bExit=false;   
std::string gRingBuffer[LOG_SIZE];
uint32_t gRBindex=0;
std::mutex gRBMutex;

bool inWhiteList(std::string userName)
{
	for(uint32_t i=0; i<nbIdx; i++) {
		if(gAllowedUsers[i] == userName) {
			gUserNameIndex=i;
			return true;
		}
	}
	return false;
}

void addToRingBuffer(uint32_t slotID, std::string newEntry, char* color=(char*)RESET)
{
	gRBMutex.lock();
	gRingBuffer[gRBindex] = std::string(color)  + std::string("Slot ") + std::to_string(slotID)  + std::string(": ") + newEntry + std::string(RESET);
	gRBindex = (gRBindex+1)%LOG_SIZE;	
	gRBMutex.unlock();
}

void printRB()
{
	gRBMutex.lock();
	// from index to end
	for(uint32_t i=gRBindex; i<LOG_SIZE; i++)
		printf("%-s\n\r", gRingBuffer[i].c_str());
	
	// from start to index
	for(uint32_t i=0; i<gRBindex; i++)
		printf("%-s\n\r", gRingBuffer[i].c_str());
	gRBMutex.unlock();
}

std::string AccelizeLogo("\
     _    ____ ____ _____ _     ___ __________ \n\
    / \\  / ___/ ___| ____| |   |_ _|__  / ____|\n\
   / _ \\| |  | |   |  _| | |    | |  / /|  _|  \n\
  / ___ \\ |__| |___| |___| |___ | | / /_| |___ \n\
 /_/   \\_\\____\\____|_____|_____|___/____|_____|\n");
                                               

std::string  AccelizeLogoSmall("\
    _   ___ ___ ___ _    ___ _______   ___  ___ __  __   ___  ___ __  __  ___   \n\r\
   /_\\ / __/ __| __| |  |_ _|_  / __| |   \\| _ \\  \\/  | |   \\| __|  \\/  |/ _ \\ \n\r\
  / _ \\ (_| (__| _|| |__ | | / /| _|  | |) |   / |\\/| | | |) | _|| |\\/| | (_) | \n\r\
 /_/ \\_\\___\\___|___|____|___/___|___| |___/|_|_\\_|  |_| |___/|___|_|  |_|\\___/ \n\r");


const char* centered(int width, const string& str) {
    int len = str.length();
    if(width < len) { return str.c_str(); }

    int diff = width - len;
    int pad1 = diff/2;
    int pad2 = diff - pad1;
    std::string ret = string(pad1, ' ') + str + string(pad2, ' ');
    return ret.c_str();
}

void printEmptyLine(char colSep='|', bool colorize=false)
{
#if 1
	printf("%c %*.*s ", '|', FCELLSIZE, FCELLSIZE, "                                   ");
    for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
		std::string cellcolor = colorize?(gIpStatusColor[gDashboard.slot[i].ipStatus]):RESET;
		printf("%c%s %*.*s %s", colSep, cellcolor.c_str(), CELLSIZE, CELLSIZE, "                                     ", RESET);
	}
	printf("%c\n\r", '|');	
#endif
}


void printDashLine(char colSep='+')
{	
	printf("%c %*.*s ", colSep, FCELLSIZE, FCELLSIZE, "---------------------------------");
    for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
		printf("%c %*.*s ", colSep, CELLSIZE, CELLSIZE, "---------------------------------");
	}
	printf("%c\n\r", colSep);	
}


void displayDashboard()
{
    uint32_t spinnerIndex = 0;
	while (!bExit) {
        clear();  
        refresh();
        clear();  
        refresh();
        
        // Print Header
        // - print accelize logo
        printf("%s\n\r", AccelizeLogoSmall.c_str());
        //printDashLine();        
        printf("%s  %c %c %c %c %c %s\n\r\n\r", BOLDWHITE, gSpinner1[spinnerIndex%maxSpinIdx], gSpinner2[spinnerIndex%maxSpinIdx], gSpinner3[spinnerIndex%maxSpinIdx], gSpinner4[spinnerIndex%maxSpinIdx], gSpinner5[spinnerIndex%maxSpinIdx], RESET);
        spinnerIndex++;
        // - print User Name
        printDashLine();
        std::string label = centered(FCELLSIZE + (CELLSIZE+3)*(gDashboard.nbSlots), gUserName + std::string(" - ") + gLicenseModeStr[gUserNameIndex]);
		printf("| %s%s%s |\n\r", BOLDWHITE, label.c_str(), RESET);
        printDashLine();        
        
        // Print Slots IDs      
        printEmptyLine('|');
        printf("|%s %s %s", BOLDWHITE, centered(FCELLSIZE, "FPGA Board"), RESET);        
        for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
            std::string index = std::to_string(i+1);
            printf("| %s ", centered(CELLSIZE, index));
        }
        printf("|\n\r");
        printEmptyLine('|');        
        printDashLine();        
        
        // Print Slots Status  
        printEmptyLine('|');      
        printf("|%s %s %s", BOLDWHITE, centered(FCELLSIZE, "App On/Off"), RESET);        
        for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
            const char* hlColor = (gDashboard.hlCell.slotID==i)?HLCOLOR:RESET;
            std::string status = gAppStatusStr[gDashboard.slot[i].slotStatus];            
            printf("|%s %s %s", hlColor, centered(CELLSIZE, status), RESET);
        }
        printf("|\n\r");    
        printEmptyLine('|');    
        printDashLine();
        
        // Print Licensing Status
        printEmptyLine('|', true);
        printf("|%s %s %s", BOLDWHITE, centered(FCELLSIZE, "App Status"), RESET);
        for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
            std::string ipstatus = gIpStatusStr[gDashboard.slot[i].ipStatus];
            std::string ipstatcolor = gIpStatusColor[gDashboard.slot[i].ipStatus];
            printf("|%s %s %s", ipstatcolor.c_str(), centered(CELLSIZE, ipstatus), RESET);
        }
        printf("|\n\r");   
        printEmptyLine('|', true);     
        printDashLine();
        
        // Print STATE
        printEmptyLine('|');
        printf("|%s %s %s", BOLDWHITE, centered(FCELLSIZE, "STATE"), RESET);
        for(uint32_t i=0; i<gDashboard.nbSlots; i++) {
			std::string state = gSlotStateStr[gDashboard.slot[i].slotState];
            printf("|%s %s %s", RESET, centered(CELLSIZE, state), RESET);
        }
        printf("|\n\r"); 
        printEmptyLine('|');       
        printDashLine();
                
        // Print log
        printf("\n\r");
		printDashLine();
        printRB();
        printDashLine();
        
        sleep(1);
    }
    return;
}

/**
 * 
 */
void update(void)
{
	gDashboard.slot[gDashboard.hlCell.slotID].slotStatus = !gDashboard.slot[gDashboard.hlCell.slotID].slotStatus;
	gDashboard.slot[gDashboard.hlCell.slotID].ipStatus = gDashboard.slot[gDashboard.hlCell.slotID].slotStatus?IP_STATUS_STARTING:IP_STATUS_UNKNOWN;
				
}

/**
 * 
 */
uint32_t getCellIdFromMouseCoord(uint32_t x, uint32_t y) 
{	
	if(y < 5)
		bExit = true;
	
	if(x < (FCELLSIZE+4))
		return 0;
	if(x> ((FCELLSIZE+4) + gDashboard.nbSlots*(CELLSIZE+3)))
		return gDashboard.nbSlots-1;
	return (x-(FCELLSIZE+4)) / (CELLSIZE+3);
}

/**
 * Input Events thread
 */
void InputEventsThread()
{	
	uint32_t savedSlotId = 0;
	
	/* Get all the mouse events */
	MEVENT event;
	mousemask(BUTTON1_CLICKED|REPORT_MOUSE_POSITION, NULL);
	
    while (!bExit) {
        timeout(1);
        nodelay(stdscr, TRUE);
        int key = getch();
        switch(key) {
			case KEY_MOUSE:
				if(getmouse(&event)==OK) {
					gDashboard.hlCell.slotID = getCellIdFromMouseCoord(event.x, event.y);
					if(savedSlotId == gDashboard.hlCell.slotID)				
						update();
					else
						savedSlotId = gDashboard.hlCell.slotID;					
				}
				break;				
			case KEY_LEFT:
				if(gDashboard.hlCell.slotID == 0)
					gDashboard.hlCell.slotID = gDashboard.nbSlots-1;
				else
					gDashboard.hlCell.slotID -= 1;
				break;
			case KEY_RIGHT:
				if(gDashboard.hlCell.slotID == (gDashboard.nbSlots-1))
					gDashboard.hlCell.slotID = 0;
				else
					gDashboard.hlCell.slotID += 1;
				break;
			case ' ':
			case '\n':
				update();
				break;				
            case ERR:
                break;
            case 'q':
            case 'Q':
                bExit = true;
                break;
            default:
                break;
        }
    }
    return;
}
